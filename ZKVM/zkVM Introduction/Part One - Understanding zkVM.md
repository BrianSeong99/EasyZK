# zkVM Part One - Understanding zkVM
![alt text](pics/zkVM-PartOneBanner.png)
*The Realm of “ZK Everything” - General-purposed Zero Knowledge Virtual Machine*

*By @BrianSeong99*

*Special Thanks to Keith Chen from SNZ for the review!*

Today, I would like to share my learnings after 3 weeks of researching zkVM, aka Zero Knowledge Virtual Machine. This is a heavy topic to cover so I divided the content into three articles:

- [Part One - Understanding zkVM](https://www.brianseong99.com/post/zkvm-part-one-understanding-zkvm): Introducing the concept of zkVM and the general execution pipeline of zkVM.

- [Part Two - Design Constraints of zkVM](https://www.brianseong99.com/post/zkvm-part-two-design-considerations-of-zkvm): Elaborate further on the design constraints when it comes to building a zkVM, which includes the zero-knowledge proof stack and the virtual machine design.

- [Part Three - Exploring zkVM Projects, Comparison, and Future](): Dive into the different designs and implementations of existing zkVM projects, and compare their advantages and disadvantages. And Last I will share a little bit of my thoughts on the future of zkVM.

<center>----------Enjoy!-----------</center>
<br/>
<br/>

# Introduction
With the recent announcement of RISCZERO getting a 40M Series A investment, the market has started to show more interest in the concept and potential future with zkVM. 


# Why do we need zkVM?
“General Purpose Verifiable Computation” is the term I would like to use to describe the future of ZK.

- AI is more and more powerful, how to ensure certain things are actually generated by someone instead of AI?

- Passing over sensitive data like your SSN and passport Number to certain applications, how do you ensure the company that collects them not doing any malicious operations with it?

- If a decentralized computation structure exists, how do you ensure the integrity of the community-operated nodes besides just trusting them?

- And of course, off-chain computation where blockchain can be used only for state management to maximize efficiency.

- more….

zkVM can be the channel for general purpose verifiable computation, the service you requested, will actually be done and you can check if it's done properly, without trusting the service provider but to challenge and verify their actions.


Here’s a good [reference](https://youtu.be/MYYb5TXdm4c?si=pXkaBBikp29kBQd7) from @[RiscZero](https://twitter.com/RiscZero) CEO @[BrianRetford](https://twitter.com/BrianRetford) sharing his insights about zkVM.


# I know zkEVM, but now zkVM? What’s the difference?

It is important to note that zkVM is very different from zkEVM. The difference is that zkEVM is primarily designed around the solidity bytecode, aka EVM assembly code where it has a lot of Ethereum-focused bytecodes that are not ZK-friendly. 


Whereas **zkVM** refers to a virtual machines that can execute a program, which is compiled from one or more programming languages into more zk-friendly instruction sets or existing Instruction sets, and generate proofs of all the execution traces of the program execution. The reason why zk-friendly or existing Instruction sets are better than EVM bytecodes in the context of ZK is that most of them are not as complex as EVM bytecodes, mostly composed of basic arithmetic operations, memory operations, and flow control operations, and maybe some field operations or other zk operations. 


One could say zkEVM is more application-specific version of zkVM, at least that’s the literal understanding. 


# Understanding zkVM

What are the major components of a zkVM?
zkVM can be mainly divided into two(three) major key components:

Virtual Machine: A system created to create an execution environment abstraction for software execution.

Zero Knowledge Proof: Generate proofs of the execution traces of the VM execution, generate a succinct proof, and verify fast.

(Optional) IR & ISA: If the system decides to use its own custom-designed ISA(Instruction sets architecture) for better ZK performance, then one would have to design their own backend compiler to translate IR (usually LLVM IR) or a compiler that translates conventional programming languages into their custom ISA directly for their VM execution.


# General Procedure of zkVM Execution

Now that you know what are the major components of zkVM, let’s take a look at the zkVM execution procedure of all walkthroughs for better understanding.


The general execution pipeline of zkVM can be broken down into the following steps:

Client/User will provide code in Rustlang/C++/Ruby or others

A compiler of the language will interpret the code into LLVM IR-like Intermediate Representation, a more efficient compiler will even try to optimize the IR(e.g. LLVM IR) for better performance. This is also called the frontend of the compiler process.

After that, there will be another conversion from IR to target assembly code, like RISCV, MIPS, and other custom codes. This is the backend of the compiler process. Please note, there are implementations that directly compile conventional programming languages into target assembly code as well, basically merging step 2 and step 3.

Now the zkVM will be executing the backend code, and record its execution trace, which is basically a data table that records every step change in the zkVM.

Once all computation is done, the machine will start working on generating proof out of the execution trace and send the proof and the final data/state to the verifier. (This is the part that takes the most time!) 

Last but not least, the result will be sent to the verifier(who could be the client/user themself), and the verifier will verify and accept the result/final state of the VM.


<center> ----------End!-----------</center>
<br/>
<br/>

In the next article, I will dive deeper into the design constraints of zkVM, will require quite some computer science knowledge to thoroughly understand it but if you can understand them, you should start thinking about working in the zkVM field!

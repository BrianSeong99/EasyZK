# Nexus 中文白皮书

翻译者 Brian Seong

## Abstract

我们介绍 Nexus 项目，这是一个旨在实现可验证计算的互联网规模的努力。自图灵在 1936 年引入通用计算机的概念——一种假想的机器，能够执行任何计算以来，世界已经取得了巨大的进步。这一概念被认为是通用计算机的起源，并被冯·诺伊曼用来介绍冯·诺伊曼架构——通用图灵机的物理实例化。现在，这种架构几乎支持着所有现代计算机的运行。

在本文中，我们介绍了 Nexus zkVM（零知识虚拟机），这是一种能够证明任何计算的机器。也就是说，该机器可以为任何状态机（例如 RISC-V、EVM、Wasm）及其特定指令集，生成简洁的零知识证明，证明程序执行是正确的。Nexus zkVM 专注于证明大型计算（例如超过 10 亿 CPU 周期）并且被设计为支持大规模并行增量证明生成，非常适合在分布式证明网络中并行证明。

zkVM 由现代高速递归证明系统（即folding/accumulation）支持，这些系统允许将证明组合并聚合，实现了增量可验证计算（IVC）及其概念上的泛化——携带证明的数据（Proof Carrying Data - PCD）。此外，我们引入了 Nexus 虚拟机（NVM），这是一个简单、最小且可扩展的通用图灵机：一种专为最大化验证者性能而设计的虚拟 CPU 架构。NVM 是 Nexus zkVM 的核心计算模型，可以以最小的开销，编译和仿真技术以及指令集扩展（例如 SHA-256）来模拟任何其他 ISA（如 RISC-V、EVM、Wasm 等）。

我们简要描述了即将推出的 Nexus 网络，这是一个大规模分布式验证者网络，它聚合了一组异构计算机的集体 CPU/GPU 力量，以实例化一个极度并行化的大规模证明生成系统，为 Nexus zkVM 提供服务。这使得 zkVM 能够以与网络集体计算能力成正比的规模（以每秒验证的 CPU 周期数衡量）运行。

从根本上说，Nexus 项目旨在通过各种科学、工程和经济技术将可验证计算的具体成本降低数个数量级，使其最终成为一种实用的计算形式。该项目建立在几十年的科学研究基础之上，包括密码学、复杂性理论、编译器和高性能计算等领域。我们专注于提供简单的开发者体验和一个旨在支持生产级应用的系统设计，初始支持 Rust 程序。

我们设想了一个互联网的未来，其中计算和数据的完整性由证明保护：一个通过数学真理增强人类合作的未来。这构成了我们迈向这一愿景的第一步建设。

## 1 Summary
在这份白皮书中，我们描述了 Nexus 项目的愿景以及我们的第一套技术。有关正式处理和新技术，请参阅我们的后续技术论文。

简而言之：Nexus 正在构建一个分布式 zkVM，旨在**每秒证明一万亿 CPU 周期**。

我们相信，世界上的计算机可以联合成为一个单一的可验证超级计算机，并共同证明人类的计算。

如何阅读。本文档的技术细节程度逐渐增加。

- 对于普通读者：我们建议阅读摘要（第1节）以了解：
  1. Nexus zkVM（第1.1节）
  2. Nexus 虚拟机（第1.2节和1.3节）
  3. Nexus 网络（第1.4节）

- 对于开发者：我们建议查看示例（第1.6节）和开源实现（第1.5节）以及官方 Nexus 文档 https://docs.nexus.xyz。

- 对于高级读者和密码学家：我们建议阅读引言（第2节）和历史背景（第3节）。要深入了解 Nexus zkVM，我们建议从第4节开始阅读。

有关问题、反馈或参与，请通过 hello@nexus.xyz 与我们联系。

### 1.1 Nexus zkVM

Nexus zkVM，这是一种能够证明任何计算的机器。我们的实现是完全开源的。zkVM 专注于证明非常大的计算量（例如，超过10亿+ CPU 周期）。它通过极端并行化实现这一目标：zkVM 实现了轻量级和无限制的增量可验证计算（IVC）[Val08]，这是一种允许通过使用现代高速递归零知识证明系统（即Folding/Accumulation Schemes）[KST22;KS22;KS23b;KS23a;BC23] 来增量计算和更新正确计算的证明的原语。这些技术使得证明可以高速累积（参见图1），并且完全不使用 SNARKs。

![](./pics/Figure1.png)
图1：一个深度为 η 的 r-元证明累积树，不使用 SNARKs。

证明累积（不使用 SNARKs），见图1，是一种新颖的技术，允许将证明组合并聚合，这本身就允许在大规模的不受信任计算机网络中高效执行证明生成。通过这种方式，zkVM 有效地实现了携带证明的数据（PCD）[CT10]的概念，这是 IVC 在分布式设置中的泛化，其中证明计算由分布式证明者网络执行。然而，通过无 SNARK 递归实现高速 IVC 的代价是大型证明。为了解决这个问题，我们通过一系列的 SNARKs 递归来压缩最终累积的证明。

**执行序列**。 Nexus zkVM 的执行序列分为三个阶段，另外还有一次性的设置阶段。参见图2，了解视觉表示。

![](./pics/Figure2.png)
图 2：Nexus zkVM 执行序列。此处，F 表示 Nexus 虚拟机上的一个 CPU 周期。第二步（IVC / PCD）是大规模并行化分布式的无 SNARK 增量证明生成，在椭圆曲线的二元环[TG14;NBS23;KS23a]中出于技术原因发生。

**一次性设置**。可选地指定一个自定义机器架构 $\Xi$ = [F1 ... Fℓ] 作为 ℓ 个附加 CPU 指令的列表，并为系统生成公共参数。这只需要为给定的机器架构执行一次。

机器 $\Xi$ 可以是空列表 $\Xi$ = []（即，在 NVM 上的默认执行，见第1.2节），也可以是一个单一电路 $\Xi$ = [F1]（例如，BLS 签名聚合[BLS01]），可以是一个完整的机器架构（例如，EVM [Woo+14], 可以是RISC-V [WLPA14], Wasm [Haa+17]），或一系列自定义用户定义的指令（例如，SHA-256, ECDSA 签名），都可以用来扩展 NVM。

我们将这些扩展称为 zkVM 协处理器，请参见第1.3节。

然后，对于每个为机器 $\Xi$ 编码的程序 $\Psi$，我们执行以下步骤：

- **编译**: 将程序编译成 Nexus 虚拟机（NVM）指令集。NVM 将在机器 $\Xi$ 上执行程序 $\Psi$

- **执行**: 在 NVM 上执行程序，生成完整的执行踪迹记录。

- **折叠**: 以高度并行化的方式产生和累积 IVC 证明 $\pi_i$，为执行块。这一步骤是证明过程的核心，也是计算上最为密集的部分。然而，它极度可并行化，并且可以由分布式证明者网络完成。

每一步折叠都需要计算单个多标量乘法（MSM）。这也是递归证明组成中最低的验证者开销[KS23b]。此外，MSM 本身就高度可并行化，这已被行业努力[Aas+22]所深入研究。

- 压缩。最后，用一系列（zk）-SNARKs 压缩累积的证明。

### 1.2 Nexus 虚拟机

Nexus 虚拟机（NVM）是一个简单、最小且可扩展的指令集架构（ISA）和随机存取机（RAM），具有冯·诺依曼架构，使其能够执行通用计算。也就是说，它是一个通用图灵机。NVM 受 vnTinyRAM[CGTV20] 和 RISC-V[WLPA14] ISA 的启发，但不同于后者，它是专为最大化验证者性能而设计的。

NVM 具有以下特点：

- **一个简单的 CPU 架构**：一个简单的 32 位指令集，有 40 条指令和简化的指令解码。

- **一个简单的内存模型**：一个具有单一堆栈和堆的简单 32 位地址空间，通过 Merkle 树[Mer87]和 Poseidon 哈希[Gra+21]以增量方式进行验证。

- **一个简单的 I/O 模型**：一个简单的 32 位输入/输出模型，带有公开输入（$x$）、私有输入（$w$）和公开输出（$y$）的单磁带。给定程序 $\Psi$，NVM 根据 ISA 执行其指令，在公开和私有输入上运行，并记录结果输出。

- **可扩展性**：NVM 可以通过我们称为 zkVM 协处理器的自定义指令进行扩展。这些自定义指令是用 CCS 电路[STW23a]编写的，CCS是R1CS[GGPR13]，Plonkish[GWC19;CBBZ23]和AIR[BBHR19;Sta21;BCKL22]的泛化版本。这些电路扩展了 NVM 指令集，并可以用来加速自定义指令而不影响每周期的验证者性能。因此，Nexus 协处理器在概念上类似于 EVM 预编译指令[Woo+14]。

Nexus zkVM 可以视为 NVM（计算模型）和证明系统（验证者）的结合体。zkVM 运行 NVM 并产生完全相同的输出。此外，它还构建了一个证明正确计算的简洁证明。也就是说，zkVM 在零知识中证明了一个私有见证 $w$ 的知识，以便 $\Psi (x, w) = y$。请注意，由于压缩步骤结束时的 zk-SNARK（见图 2），Nexus zkVM 实际上是零知识的（也就是说，不仅是简洁的），并且假设验证者没有泄露信息，它隐藏了可选的私有见证 $w$。

![](./pics/Figure3.png)
图3: Nexus 虚拟机

### 1.3 Nexus zkVM 协处理器

zkVM 协处理器的概念受到[KS22]启发并且非常强大。从理论上讲，任何程序都可以作为 CPU 指令序列的一部分被证明，但在这个模型中证明许多类型的简单程序在实践中是不可行的。例如，即使是在虚拟机模型中证明单个 SHA-256 哈希，也需要证明大约 64000 个 CPU 周期，这些周期是在软件中模拟 SHA-256 函数。相比之下，直接证明一个手动编写的 SHA-256 哈希电路（类似于 ASIC）大约只涉及 30k 个约束，需要的计算量大约少 1000 倍。这就是抽象化的代价。

在传统的 zkVM 设计中（例如，vnTinyRAM[CGTV20]），人们使用通用电路来模拟整个 CPU。在 CPU 中添加新指令涉及增加每一步证明的总约束数量，所以自然的策略是最小化被证明的 CPU 的大小。

为了打破这种 CPU 与 ASIC 的困境，Nexus zkVM 引入了 zkVM 协处理器的概念，当被主程序执行时，只有在执行特定的协处理器时，验证者才需要支付扩展 NVM 指令集的证明成本。这允许 Nexus zkVM 保持对开发者友好的 CPU 抽象和一个小型的图灵完备 ISA，同时允许在指令集上进行类似 ASIC 的扩展（见图 5），而只有在实际执行这些指令时才需要支付这些指令的成本。由于最近在非单一 IVC 和相关折叠/累积技术方面的进步[KS22;BC23;ZGGX23;AST23;GHK23]，这些技术成为可能。

特别是，zkVM 协处理器允许 zkVM 加速自定义密码原语（例如，SHA-256、ECDSA 签名）、高级操作（例如，矩阵乘法、计算平方根等）甚至通过将其他 SNARK 的验证器电路作为自定义指令注入 zkVM，从而递归地组合其他 SNARK。缺点是这些自定义用途的电路需要手动实现，但它们只需要实现一次。

**简洁性与普遍性**。除了为验证者性能优化之外，NVM 还试图回答一个社会性问题：我们能否设计一个足够简单的通用计算模型（即通用图灵机的具体实例），使得在 NVM 上的计算证明能够普遍令人信服？

例如，考虑通过在 x86 机器（具有 $2^{120}$ 个潜在指令和大型架构复杂性）上仿真得到证明 $\pi_1$，与在一个只有基本 ADD、SUB、XOR 等指令的 32 指令机器上仿真得到的证明 $\pi_2$，哪一个证明 $\pi_1$ 或 $\pi_2$ 更令人信服作为 $Fib(n)$ 计算的真实证明？哪一个证明 $\pi_1$ 或 $\pi_2$ 在未来 10 年的某个时间点可能更令人信服？哪一个验证器电路可能更容易实现和审计？

![](./pics/Figure4.png)
图4: Nexus虚拟机（NVM）的指令集架构（ISA）

![](./pics/Figure5.png)
图5: Nexus 虚拟机 zkVM 协处理器的设计，旨在允许 NVM 指令集上的加速指令获得类似 ASIC 的性能。

### 1.4 Nexus 网络

Nexus 项目致力于在互联网规模上实现可验证计算。为此，我们提出了一个系统，该系统将能够把 Nexus zkVM 的总吞吐量提高数个数量级。我们将这个系统称为 Nexus 网络，这是一个汇集了异构计算机网络的集体 CPU / GPU 力量，以实例化一个极度并行化的大规模证明生成系统，为 Nexus zkVM 提供服务。这允许 zkVM 以与网络集体计算能力成比例的规模（以每秒 CPU 证明的周期数衡量）运行。

**分布式超级计算机**。在互联网上的大规模志愿者计算在一些著名项目中取得了巨大成功。这些项目利用了数百万志愿者的集体计算能力，解决了大规模的科学问题，这些系统的总计算能力以每秒浮点运算次数（FLOPS）来衡量。例如：

- 1996年的大互联网梅森素数搜索（GIMPS）[96]，在2004年初达到了14 teraFLOPS的速度。
- 1999年的SETI@Home[And+02]来自NASA，该项目在2008年获得了吉尼斯世界记录，作为历史上最大的计算，达到了668 teraFLOPS。
- 2000年的Folding@Home[Beb+09]来自斯坦福大学，达到了2.43 exaFLOPS，成为第一个 exaFLOP 计算系统。

Nexus 网络试图做同样的事情，但针对的是可验证计算的问题。因此，Nexus 网络可以被看作是一个分布式的可验证超级计算机，它允许 zkVM 根据网络的集体计算能力按比例扩展其吞吐量。

![](./pics/Figure6.png)
图 6：Nexus 网络。证明在类似树的方式中进行聚合。

**在分布式计算中的可验证性**。上述提到的项目依赖于各种启发式方法来确保分布式计算的完整性。例如，SETI@Home 依靠在多个节点之间复制计算，然后比较结果。如果出现分歧，计算将由另一组随机选择的志愿者重复。这最多只能提供关于计算完整性的概率保证。

相比之下，Nexus 网络提供了关于分布式计算完整性的可证明保证，因为输出本身就是一个证明。请注意，这不仅适用于最终证明，也适用于增量可验证计算中的所有中间证明。因为第一次实例化基于 Nexus 网络的高速递归证明聚合技术的 Proof-Carrying Data 系统，在实际中成为可能。

**一个可验证的超级计算机**: 因此，我们提出了一个大胆的问题：

我们能否能将世界上的计算机联合成一个单一的可验证超级计算机？

特别是，我们认为如果有足够的计算能力，Nexus zkVM 可能会达到每秒数万亿 CPU 周期，从而能够证明目前所能实现的计算量级大得多的计算。Nexus 网络是朝向这一愿景的第一步。

**实际问题**: Nexus zkVM 将证明过程分成可以任意小的计算块，然后逐步累积证明。由于这一点，Nexus 证明者可以在只有 1GB RAM 的情况下运行。这使得即使是像智能手机和笔记本电脑这样的小型设备也能参与到网络中并提供有用的计算资源。在实践中，我们预计强大的证明者将主导系统中的计算供应，因为优化用于计算多标量乘法（MSMs）的 GPU、FPGA 或 ASIC 集群，其计算能力要强大得多。

### 1.5 开源实现

那么，到底实现了什么？Nexus zkVM 和 Nexus 网络都是完全开源的，并且都是用 Rust 实现的。这些包括：

1. **证明累积**: Nova、CycleFold 和 HyperNova。继 Microsoft Research 在2022年发布原始开源实现 Nova[KST22]之后，我们提供了第一个从零开始构建的 Nova 和后续证明累积系统的生产级实现，所有这些都在 arkworks[ark22]构建：

   - Nova 折叠方案[KST22]
   - CycleFold 多折叠方案[KS23a]
   - Nova + CycleFold IVC 证明系统（参见第5.4节）
   - 二叉树并行化的 Nova 方案（参见第5.6节）
   - 正在进行中的 CCS[STW23a]和 HyperNova[KS23b]的第一个实现

   我们希望这些对社区和其他项目同样有用。我们正在使用新技术[BC23;ZZD23;ZGGX23]积极改进这些。我们的实现具体展示了 Nova 与 CycleFold 的 50k 递归开销（以约束数量衡量），以及带有 CycleFold 的并行 Nova 的 200k 递归开销。我们将在后续技术论文中报告 HyperNova 的测量结果。

2. **Nexus zkVM**: Nexus zkVM 和所有执行序列步骤的实现：生成、编译（见证提取）、执行、折叠和证明压缩。参见图2。

   使用 Nexus zkVM 对任何 Rust 程序，如示例1，进行证明就像执行以下操作一样简单：

   ```bash
   $ cargo nexus prove → $ cargo nexus verify
   ```

3. **Nexus 虚拟机**。NVM 和其算术化版本在 R1CS 的实现，以及用于内存检查的 Merkle 证明，还有一个 RISC-V 到 NVM 的编译器。

   NVM 的算术化，尽管还相当原始，仍然是每个 CPU 周期大小为 30k 的电路。这是一个大型电路（主要是由于内存检查），但我们预期即将到来的改进的内存检查技术将使机器大小减少10倍，而更大的数量级改进将来自于使用 zkVM 协处理器[KS22; ZGGX23; GHK23]和查找参数[STW23b; AST23]。

   普通用户不必担心这个中间优化步骤，但它会从编译器优化带来显著的性能提升，并由于机器的简单性而更加安全。

4. **Nexus 网络**。Nexus 网络的开源实现，包括三种不同类型的节点：

   - **Nexus MSM Prover**，一个可以在至少有 1GB RAM 的任何机器上运行的证明者节点。这些节点通过按需计算 MSMs 为网络提供计算资源。向系统提供计算资源就像执行以下操作一样简单：

      ```bash
      $ cargo nexus compute
      ```

   - **Nexus PCD Prover**，一个可以在任何机器上运行并为网络提供计算资源的证明者节点。Nexus 团队目前在操作这些节点。

   - **Nexus Aggregator**，一个聚合证明并通过应用 Nexus zk-SNARK 压缩序列（参见图2）使用 SNARKs 压缩它们的节点。

5. **Nexus 证明压缩序列**。

   我们呈现：
   - **一个 Nova 友好的 zkSNARK**。除了 Microsoft 的实现[KST22]之外，第一个为累积友好型通用 R1CS 的 zk-SNARK 实现：一个针对提交的松散 R1CS[KST22]关系的修改版 Spartan[Set20] zk-SNARK，从原始的 Spartan[ark22]实现中为 R1CS 适应。
   - Zeromorph[KT23]多项式承诺方案的实现。

   我们进一步应用其他 SNARKs[Gro16;BGH19;BGH20]的最终层次的证明压缩，以实现 Nova 证明的以太坊可验证性，这允许 Nexus 连接到以太坊。这些细节将在技术论文中描述。

尚未实现的内容：
   - **非均匀性**。我们目前的实现是完全均匀的 IVC（见图5），但不是非均匀的。支持 CCS 扩展正在积极开发中。
   - **zkVM I/O**。当前的 Nexus zkVM 还不支持 I/O（例如，加载一个 JSON 文件）。所有输入必须在程序本身中编码。这是一个小但重要的限制，将在接下来的几周内解决。

### 1.6 示例

这是一个可在 Nexus zkVM 上证明的 Rust 程序示例。这段代码展示了如何用 Nexus 编写简单的斐波那契数列计算程序。

```rust
#![no_std]
#![no_main]

#[nexus::main]
fn fib(n: u32) -> u32 {
    match n {
        0 => 1,
        1 => 1,
        _ => fib(n - 1) + fib(n - 2),
    }
}
```

*清单 1: 可在 Nexus zkVM 上证明的 Rust 程序示例。*

